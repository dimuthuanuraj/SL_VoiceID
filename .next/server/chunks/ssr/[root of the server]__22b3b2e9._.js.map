{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/firebase.ts"],"sourcesContent":["\n// Import the functions you need from the SDKs you need\nimport { initializeApp, getApps, getApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\nimport { getFirestore } from \"firebase/firestore\";\n\n// VITAL: PASTE YOUR FIREBASE CONFIGURATION OBJECT HERE\n// The error \"auth/api-key-not-valid\" means the values below are incorrect.\n// 1. Go to your Firebase project console.\n// 2. In Project settings > General tab, find your web app.\n// 3. Copy the 'firebaseConfig' object and paste it below, replacing the placeholder.\n//\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain:  process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket:  process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId:  process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId:  process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\n\n\n// Initialize Firebase\n// This line checks if a Firebase app is already initialized to prevent errors.\nconst app = !getApps().length ? initializeApp(firebaseConfig) : getApp();\nconst auth = getAuth(app);\nconst db = getFirestore(app);\n\nexport { app, auth, db };\n"],"names":[],"mappings":"AACA,uDAAuD;;;;;;AACvD;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA,uDAAuD;AACvD,2EAA2E;AAC3E,0CAA0C;AAC1C,2DAA2D;AAC3D,qFAAqF;AACrF,EAAE;AACF,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACP;AAIA,sBAAsB;AACtB,+EAA+E;AAC/E,MAAM,MAAM,CAAC,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,GAAG,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE,kBAAkB,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;AACrE,MAAM,OAAO,CAAA,GAAA,yOAAA,CAAA,UAAO,AAAD,EAAE;AACrB,MAAM,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/user-service.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview User Service for Firebase Firestore\n * This service manages speaker profiles in the Firestore database.\n */\n\nimport { db } from './firebase'; \nimport { collection, doc, setDoc, getDocs, query, where, getDoc, runTransaction } from 'firebase/firestore';\nimport type { SpeakerProfile } from './speaker-id';\n\nconst USERS_COLLECTION = 'users';\nconst COUNTER_DOCUMENT = '--counter--';\nconst STARTING_NUMERIC_ID = 90000;\n\n\n/**\n * Generates the next unique Speaker ID by using a Firestore transaction to atomically increment a counter.\n * This is a robust, server-side method to ensure unique, sequential IDs without race conditions.\n * @returns A promise that resolves to the next unique speaker ID (e.g., \"id90001\").\n */\nexport async function generateNextSpeakerId(): Promise<string> {\n    const counterRef = doc(db, USERS_COLLECTION, COUNTER_DOCUMENT);\n\n    try {\n        const newNumericId = await runTransaction(db, async (transaction) => {\n            const counterDoc = await transaction.get(counterRef);\n            \n            let nextId: number;\n            if (!counterDoc.exists() || !counterDoc.data().lastId) {\n                console.log(\"Counter document not found. Initializing with starting ID.\");\n                nextId = STARTING_NUMERIC_ID;\n            } else {\n                const lastId = counterDoc.data().lastId as number;\n                if(lastId < STARTING_NUMERIC_ID) {\n                    console.warn(`Stored lastId (${lastId}) is less than the starting ID. Resetting.`);\n                    nextId = STARTING_NUMERIC_ID;\n                } else {\n                    nextId = lastId + 1;\n                }\n            }\n            \n            transaction.set(counterRef, { lastId: nextId }, { merge: true });\n            return nextId;\n        });\n\n        return `id${newNumericId}`;\n\n    } catch (error) {\n        console.error(\"Error generating next speaker ID:\", error);\n        throw new Error(\"Could not generate a unique Speaker ID.\");\n    }\n}\n\n\n/**\n * Adds or updates a speaker's profile in the Firestore database.\n * The document ID is the user's unique Firebase Authentication UID.\n * @param uid - The Firebase Authentication user ID.\n * @param userProfile - The speaker profile object.\n * @returns A promise that resolves when the operation is complete.\n */\nexport async function addUserProfile(uid: string, userProfile: SpeakerProfile): Promise<void> {\n  try {\n    const userDocRef = doc(db, USERS_COLLECTION, uid);\n    await setDoc(userDocRef, userProfile);\n    console.log(`User profile for UID ${uid} (Speaker ID: ${userProfile.speakerId}) saved successfully.`);\n  } catch (error) {\n    console.error(\"Error saving user profile to Firestore:\", error);\n    throw new Error('Could not save user profile.');\n  }\n}\n\n/**\n * Retrieves a single speaker profile from Firestore by their Firebase Auth UID.\n * @param uid The Firebase Authentication user ID.\n * @returns A promise that resolves to the SpeakerProfile object or null if not found.\n */\nexport async function getUserProfile(uid: string): Promise<SpeakerProfile | null> {\n    try {\n        const userDocRef = doc(db, USERS_COLLECTION, uid);\n        const docSnap = await getDoc(userDocRef);\n\n        if (docSnap.exists()) {\n            return docSnap.data() as SpeakerProfile;\n        } else {\n            console.log(`No user profile found for UID: ${uid}`);\n            return null;\n        }\n    } catch (error) {\n        console.error(\"Error fetching user by UID:\", error);\n        throw new Error(\"Could not fetch user profile.\");\n    }\n}\n\n\n/**\n * Retrieves a single speaker profile from Firestore by their Speaker ID.\n * This performs a query, as speakerId is not the document ID.\n * @param speakerId The ID of the speaker to retrieve (e.g., 'id90001').\n * @returns A promise that resolves to the SpeakerProfile object or null if not found.\n */\nexport async function getUserBySpeakerId(speakerId: string): Promise<SpeakerProfile | null> {\n    try {\n        const usersCollectionRef = collection(db, USERS_COLLECTION);\n        const q = query(usersCollectionRef, where(\"speakerId\", \"==\", speakerId));\n        const querySnapshot = await getDocs(q);\n\n        if (querySnapshot.empty) {\n            console.log(`No user profile found for speakerId: ${speakerId}`);\n            return null;\n        }\n        \n        // Assuming speakerId is unique, return the first found document.\n        const userDoc = querySnapshot.docs[0];\n        return userDoc.data() as SpeakerProfile;\n\n    } catch (error) {\n        console.error(\"Error fetching user by speakerId:\", error);\n        throw new Error(\"Could not fetch user profile by Speaker ID.\");\n    }\n}\n\n\n/**\n * Retrieves all registered speaker profiles from Firestore.\n * @returns A promise that resolves to an array of SpeakerProfile objects.\n */\nexport async function getAllUsers(): Promise<SpeakerProfile[]> {\n  try {\n    const usersCollectionRef = collection(db, USERS_COLLECTION);\n    const q = query(usersCollectionRef, where(\"speakerId\", \"!=\", null)); // Filter out counter doc\n    const querySnapshot = await getDocs(q);\n    \n    const users: SpeakerProfile[] = [];\n    querySnapshot.forEach((doc) => {\n      // Type assertion to ensure the data matches the SpeakerProfile interface\n      users.push(doc.data() as SpeakerProfile);\n    });\n    \n    console.log(`Fetched ${users.length} registered speakers.`);\n    return users;\n\n  } catch (error) {\n    console.error(\"Error retrieving registered speakers from Firestore:\", error);\n    throw new Error('Could not retrieve registered speakers.');\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 553, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-reading-phrase-flow.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Generates random short sentences for audio recording.\n *\n * - generateReadingPhrase - A function that generates a phrase.\n * - GenerateReadingPhraseInput - The input type for the generateReadingPhrase function.\n * - GenerateReadingPhraseOutput - The return type for the generateReadingPhrase function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst GenerateReadingPhraseInputSchema = z.object({\n  language: z.enum(['Sinhala', 'Tamil', 'English']).describe('The language for the phrase (Sinhala, Tamil, or English).'),\n});\nexport type GenerateReadingPhraseInput = z.infer<typeof GenerateReadingPhraseInputSchema>;\n\nconst GenerateReadingPhraseOutputSchema = z.object({\n  phrase: z.string().describe('A short sentence in the specified language, designed to be read aloud in approximately 8-15 seconds.'),\n});\nexport type GenerateReadingPhraseOutput = z.infer<typeof GenerateReadingPhraseOutputSchema>;\n\nexport async function generateReadingPhrase(input: GenerateReadingPhraseInput): Promise<GenerateReadingPhraseOutput> {\n  return generateReadingPhraseFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateReadingPhrasePrompt',\n  input: {schema: GenerateReadingPhraseInputSchema},\n  output: {schema: GenerateReadingPhraseOutputSchema},\n  prompt: `You are a creative assistant tasked with generating short, natural-sounding sentences for a voice recording application.\nThe sentence should be in {{language}}.\nThe sentence must be suitable for a native or fluent speaker to read aloud in approximately 8 to 15 seconds.\nThe sentence should be grammatically correct, common, and easy to understand. Avoid complex jargon, proper nouns (unless very common like a country name), or overly specific topics.\nGenerate only one sentence.\n\nLanguage: {{language}}\nDesired reading time: 8-15 seconds.\n\nExample for Sinhala (if language is Sinhala): \"අහස නිල් පාටයි, සමහර වලාකුළු සුදු පාටයි, ඒ වගේම හිරු එළිය දීප්තිමත්ව බබලනවා.\"\nExample for Tamil (if language is Tamil): \"வானம் நீல நிறமாகவும், சில மேகங்கள் வெண்மையாகவும், சூரியன் பிரகாசமாகவும் பிரகாசிக்கிறது.\"\nExample for English (if language is English): \"The sky is blue, some clouds are white, and a smile can brighten anyone's day, can't it?\"\n\nReturn ONLY the generated sentence as the 'phrase' output.\n`,\n});\n\nconst generateReadingPhraseFlow = ai.defineFlow(\n  {\n    name: 'generateReadingPhraseFlow',\n    inputSchema: GenerateReadingPhraseInputSchema,\n    outputSchema: GenerateReadingPhraseOutputSchema,\n  },\n  async (input) => {\n    // For very short generations like this, a higher temperature can lead to more varied and natural sentences.\n    // However, for consistency in meeting the \"8-15 second\" read time, a moderate temperature is safer.\n    const {output} = await prompt(input, {config: {temperature: 0.6}});\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,mCAAmC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,UAAU,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAW;QAAS;KAAU,EAAE,QAAQ,CAAC;AAC7D;AAGA,MAAM,oCAAoC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACjD,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGO,eAAe,uCAAmB,GAAnB,sBAAsB,KAAiC;IAC3E,OAAO,0BAA0B;AACnC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAAgC;IAChD,QAAQ;QAAC,QAAQ;IAAiC;IAClD,QAAQ,CAAC;;;;;;;;;;;;;;AAcX,CAAC;AACD;AAEA,MAAM,4BAA4B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC7C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,4GAA4G;IAC5G,oGAAoG;IACpG,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO,OAAO;QAAC,QAAQ;YAAC,aAAa;QAAG;IAAC;IAChE,OAAO;AACT;;;IApCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/google-service.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Central Google API Service\n * This service handles authentication and provides wrapper functions for interacting\n * with Google Drive and Google Sheets APIs using a service account.\n */\nimport { google } from 'googleapis';\n\n// Interface for file metadata, aligned with what we extract and store.\nexport interface FileMetadata {\n  id: string;\n  name: string;\n  mimeType: string;\n  createdTime: string;\n  speakerId?: string;\n  recordedLanguage?: string;\n  phraseIndex?: number;\n  phraseText?: string;\n  duration?: string;\n  driveLink?: string;\n}\n\n\n// --- Authentication ---\nconst SCOPES = [\n  'https://www.googleapis.com/auth/drive',\n  'https://www.googleapis.com/auth/spreadsheets',\n];\n\n// This function creates an authenticated Google API client.\n// It uses service account credentials stored in environment variables.\nfunction getAuthenticatedClient() {\n  const privateKey = process.env.GOOGLE_PRIVATE_KEY?.replace(/\\\\n/g, '\\n');\n  if (!process.env.GOOGLE_CLIENT_EMAIL || !privateKey) {\n    throw new Error('Google service account credentials (GOOGLE_CLIENT_EMAIL, GOOGLE_PRIVATE_KEY) are not set in .env');\n  }\n\n  const auth = new google.auth.GoogleAuth({\n    credentials: {\n      client_email: process.env.GOOGLE_CLIENT_EMAIL,\n      private_key: privateKey,\n    },\n    scopes: SCOPES,\n  });\n  return auth;\n}\n\n// --- Google Drive Functions ---\n\nconst driveFolderId = process.env.DRIVE_FOLDER_ID;\n\n/**\n * Uploads a file to the configured Google Drive folder.\n * @param fileName The desired name of the file in Drive.\n * @param fileBuffer The file content.\n * @param mimeType The MIME type of the file.\n * @returns The file metadata from the Drive API response.\n */\nexport async function uploadFile(fileName: string, fileBuffer: Buffer, mimeType: string) {\n  if (!driveFolderId) {\n    throw new Error(\"DRIVE_FOLDER_ID is not set in the environment variables.\");\n  }\n  const auth = getAuthenticatedClient();\n  const drive = google.drive({ version: 'v3', auth });\n  \n  const response = await drive.files.create({\n    requestBody: {\n      name: fileName,\n      parents: [driveFolderId],\n      mimeType,\n    },\n    media: {\n      mimeType,\n      body: require('stream').Readable.from(fileBuffer),\n    },\n    fields: 'id, name',\n  });\n  \n  return response.data;\n}\n\n/**\n * Lists all files in the configured Google Drive folder.\n * It also parses metadata from the filenames.\n * @returns An array of file metadata objects.\n */\nexport async function listFiles(): Promise<FileMetadata[]> {\n  if (!driveFolderId) {\n    throw new Error(\"DRIVE_FOLDER_ID is not set in the environment variables.\");\n  }\n  const auth = getAuthenticatedClient();\n  const drive = google.drive({ version: 'v3', auth });\n\n  const response = await drive.files.list({\n    q: `'${driveFolderId}' in parents and trashed=false`,\n    fields: 'files(id, name, mimeType, createdTime)',\n    orderBy: 'createdTime desc',\n  });\n\n  if (!response.data.files) {\n    return [];\n  }\n\n  // Enrich metadata by parsing the filename\n  return response.data.files.map(file => {\n    const [speakerId, recordedLanguage, phraseInfo] = (file.name || '').split('_');\n    const phraseIndex = phraseInfo ? parseInt(phraseInfo.replace('phrase', ''), 10) : undefined;\n    \n    return {\n      id: file.id || '',\n      name: file.name || '',\n      mimeType: file.mimeType || '',\n      createdTime: file.createdTime || '',\n      speakerId: speakerId,\n      recordedLanguage: recordedLanguage,\n      phraseIndex: isNaN(phraseIndex as any) ? undefined : phraseIndex,\n      driveLink: `https://drive.google.com/file/d/${file.id}/view`,\n    };\n  });\n}\n\n/**\n * Downloads a file from Google Drive by its ID.\n * @param fileId The ID of the file to download.\n * @returns A Buffer with the file content, or null if not found.\n */\nexport async function downloadFile(fileId: string): Promise<Buffer | null> {\n  const auth = getAuthenticatedClient();\n  const drive = google.drive({ version: 'v3', auth });\n\n  try {\n    const response = await drive.files.get(\n      { fileId: fileId, alt: 'media' },\n      { responseType: 'arraybuffer' }\n    );\n    return Buffer.from(response.data as any);\n  } catch (error: any) {\n    if (error.code === 404) {\n      console.warn(`File not found in Drive with ID: ${fileId}`);\n      return null;\n    }\n    console.error(`Error downloading file from Drive:`, error);\n    throw new Error('Could not download file from Google Drive.');\n  }\n}\n\n\n// --- Google Sheets Functions ---\n\nconst sheetId = process.env.SHEET_ID;\nconst sheetRange = 'Sheet1'; // Assuming data is in 'Sheet1'\n\n/**\n * Appends a row of data to the configured Google Sheet.\n * @param rowData An array of values for the new row.\n */\nexport async function appendSheetData(rowData: any[]) {\n  if (!sheetId) {\n    throw new Error(\"SHEET_ID is not set in the environment variables.\");\n  }\n  const auth = getAuthenticatedClient();\n  const sheets = google.sheets({ version: 'v4', auth });\n\n  await sheets.spreadsheets.values.append({\n    spreadsheetId: sheetId,\n    range: sheetRange,\n    valueInputOption: 'USER_ENTERED',\n    requestBody: {\n      values: [rowData],\n    },\n  });\n}\n\n/**\n * Retrieves the header row from the Google Sheet.\n * This is useful for ensuring data is inserted correctly.\n * @returns An array of strings representing the header columns.\n */\nexport async function getGoogleSheetHeaders(): Promise<string[]> {\n    if (!sheetId) {\n        throw new Error(\"SHEET_ID is not set in the environment variables.\");\n    }\n    const auth = getAuthenticatedClient();\n    const sheets = google.sheets({ version: 'v4', auth });\n\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: sheetId,\n        range: `${sheetRange}!1:1`, // Get the first row\n    });\n\n    return response.data.values?.[0] || [];\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 845, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/google-drive-service.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Service layer that acts as a bridge to the main Google API service.\n * This file provides an abstraction layer, so if the underlying Google service changes,\n * we only need to update this file and not all the components that use it.\n */\n\nimport {\n  uploadFile as apiUploadFile,\n  listFiles as apiListFiles,\n  downloadFile as apiDownloadFile,\n  appendSheetData as apiAppendSheet,\n} from './google-service';\nimport type { FileMetadata } from './google-service';\n\n/**\n * Uploads a file to Google Drive.\n * @param fileName The name of the file.\n * @param fileBuffer The content of the file as a Buffer.\n * @param mimeType The MIME type of the file.\n * @returns A promise that resolves to the file metadata.\n */\nexport async function uploadFileToDrive(\n  fileName: string,\n  fileBuffer: Buffer,\n  mimeType: string,\n): Promise<{ id: string; name: string }> {\n  const result = await apiUploadFile(fileName, fileBuffer, mimeType);\n  if (!result || !result.id || !result.name) {\n    throw new Error('File upload to Google Drive failed to return expected data.');\n  }\n  return { id: result.id, name: result.name };\n}\n\n/**\n * Lists files from the Google Drive folder.\n * @returns A promise that resolves to an array of file metadata.\n */\nexport async function listFilesFromDrive(): Promise<FileMetadata[]> {\n  return await apiListFiles();\n}\n\n/**\n * Downloads a file from Google Drive.\n * @param fileId The ID of the file to download.\n * @returns A promise that resolves to the file content as a Buffer, or null if not found.\n */\nexport async function downloadFileFromDrive(fileId: string): Promise<Buffer | null> {\n  return await apiDownloadFile(fileId);\n}\n\n/**\n * Appends a row of data to the configured Google Sheet.\n * @param rowData An array of values for the new row.\n * @returns A promise that resolves when the data has been appended.\n */\nexport async function appendDataToGoogleSheet(rowData: any[]): Promise<void> {\n  await apiAppendSheet(rowData);\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;;;;CAIC,GAED;;;;;AAeO,eAAe,uCAAe,GAAf,kBACpB,QAAgB,EAChB,UAAkB,EAClB,QAAgB;IAEhB,MAAM,SAAS,MAAM,CAAA,GAAA,oIAAA,CAAA,aAAa,AAAD,EAAE,UAAU,YAAY;IACzD,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,IAAI,EAAE;QACzC,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;QAAE,IAAI,OAAO,EAAE;QAAE,MAAM,OAAO,IAAI;IAAC;AAC5C;AAMO,eAAe,uCAAgB,GAAhB;IACpB,OAAO,MAAM,CAAA,GAAA,oIAAA,CAAA,YAAY,AAAD;AAC1B;AAOO,eAAe,uCAAmB,GAAnB,sBAAsB,MAAc;IACxD,OAAO,MAAM,CAAA,GAAA,oIAAA,CAAA,eAAe,AAAD,EAAE;AAC/B;AAOO,eAAe,uCAAqB,GAArB,wBAAwB,OAAc;IAC1D,MAAM,CAAA,GAAA,oIAAA,CAAA,kBAAc,AAAD,EAAE;AACvB;;;IApCsB;IAgBA;IASA;IASA;;AAlCA,+OAAA;AAgBA,+OAAA;AASA,+OAAA;AASA,+OAAA","debugId":null}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions/audioDriveActions.ts"],"sourcesContent":["\n'use server';\n\nimport {\n  uploadFileToDrive as serviceUploadFile,\n  listFilesFromDrive as serviceListFiles,\n  downloadFileFromDrive as serviceDownloadFile,\n  appendDataToGoogleSheet,\n} from '@/services/google-drive-service';\nimport type { SpeakerProfile } from '@/contexts/auth-context';\nimport type { FileMetadata as DriveFileMetadata } from '@/services/google-service';\n\n\nexport interface EnrichedDriveAudioFile extends DriveFileMetadata {\n    // Client-side specific fields\n    status?: 'pending' | 'verified' | 'rejected';\n}\n\n\nexport async function uploadAudioToDriveAction(\n  formData: FormData,\n  userProfile: SpeakerProfile,\n  sessionLanguage: string,\n  phraseIndex: number,\n  phraseText: string\n): Promise<{ success: boolean; fileId?: string; fileName?: string; error?: string }> {\n  try {\n    const file = formData.get('audioBlob') as File | null;\n    const speakerId = userProfile.speakerId;\n\n    if (!file) {\n      return { success: false, error: 'No audio file provided.' };\n    }\n    if (!speakerId) {\n      return { success: false, error: 'Speaker ID is missing.' };\n    }\n    if(!sessionLanguage || !phraseText) {\n        return { success: false, error: 'Session language or phrase text missing.' };\n    }\n\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n    \n    const timestamp = new Date();\n    const isoTimestamp = timestamp.toISOString();\n    const formattedTimestamp = timestamp.toLocaleString('en-US', { timeZone: 'Asia/Colombo' });\n\n    const fileName = `${speakerId}_${sessionLanguage.toLowerCase()}_phrase${phraseIndex + 1}_${isoTimestamp.replace(/[:.]/g, '-')}.${file.name.split('.').pop() || 'webm'}`;\n\n    // 1. Upload the file to Google Drive\n    const uploadResult = await serviceUploadFile(\n        fileName, \n        buffer, \n        file.type,\n    );\n\n    if (uploadResult.id) {\n      // 2. If upload is successful, log the metadata to Google Sheets\n      const fileLink = `https://drive.google.com/file/d/${uploadResult.id}/view`;\n      \n      const sheetRow = [\n        speakerId,\n        userProfile.fullName,\n        userProfile.language, // Native Language\n        sessionLanguage, // Recorded Language\n        phraseIndex + 1,\n        phraseText,\n        fileName,\n        fileLink,\n        formattedTimestamp, // Timestamp\n        '', // Placeholder for Duration\n        'pending' // Default Status\n      ];\n\n      await appendDataToGoogleSheet(sheetRow);\n      \n      return { success: true, fileId: uploadResult.id, fileName: uploadResult.name };\n    } else {\n      return { success: false, error: 'Failed to upload file to Drive.' };\n    }\n  } catch (error) {\n    console.error('Error in uploadAudioToDriveAction:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred during upload.';\n    return { success: false, error: `Upload Action Failed: ${errorMessage}` };\n  }\n}\n\nexport async function listAudioFilesFromDriveAction(): Promise<EnrichedDriveAudioFile[]> {\n  try {\n    const files = await serviceListFiles();\n    // The service now returns enriched metadata directly from the file names.\n    // Let's sort them by creation time descending.\n    return files\n        .sort((a, b) => new Date(b.createdTime || 0).getTime() - new Date(a.createdTime || 0).getTime())\n        .map(file => ({\n            ...file,\n            status: 'pending' // Default status, would be managed elsewhere (e.g. in the sheet or a DB)\n        }));\n\n  } catch (error) {\n    console.error('Error in listAudioFilesFromDriveAction:', error);\n    return [];\n  }\n}\n\nexport async function getAudioFileFromDriveAction(fileId: string): Promise<{ success: boolean; data?: string; mimeType?: string; error?: string, fileName?: string }> {\n  try {\n    const fileContent = await serviceDownloadFile(fileId);\n    \n    if (fileContent) {\n        // We need metadata to get the name and mimeType. For now, let's list and find.\n        // This is inefficient but works for the current structure.\n        const filesMeta = await serviceListFiles();\n        const fileMeta = filesMeta.find(f => f.id === fileId);\n        \n        if (!fileMeta || !fileMeta.name || !fileMeta.mimeType) {\n            // Fallback if metadata isn't found (should be rare)\n            console.warn(`Could not find metadata for fileId ${fileId} during download.`);\n            return { success: false, error: 'File content found, but metadata is missing.' };\n        }\n\n        const base64Data = fileContent.toString('base64');\n        return { \n            success: true, \n            data: `data:${fileMeta.mimeType};base64,${base64Data}`, \n            mimeType: fileMeta.mimeType, \n            fileName: fileMeta.name \n        };\n    } else {\n      return { success: false, error: 'File not found in Google Drive.' };\n    }\n  } catch (error) {\n    console.error('Error in getAudioFileFromDriveAction:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'An unknown error occurred while fetching file.' };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1045, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1124, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 1138, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 1152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}